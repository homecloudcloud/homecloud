"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCommentSectionKeys = void 0;
const config_1 = require("../config");
const regexs_utils_1 = require("../utils/regexs.utils");
const add_key_1 = require("./add-key");
const resolvers_utils_1 = require("./utils/resolvers.utils");
function stringToKeys(valueRegex) {
    return function (str) {
        // Remove the wrapper, t(some.key) => some.key
        return (str
            .replace(valueRegex, '$1')
            // Support multi keys t(a, b.c, d)
            .split(',')
            // Remove spaces
            .map((v) => v.replace(/[*\n]/g, '').trim())
            // Remove empty keys
            .filter((key) => key.length > 0));
    };
}
function flatten(acc, strings) {
    acc.push(...strings);
    return acc;
}
function addCommentSectionKeys(_a) {
    var { content, regexFactory, read = '' } = _a, baseParams = __rest(_a, ["content", "regexFactory", "read"]);
    const marker = (0, config_1.getConfig)().marker;
    const regex = regexFactory();
    let commentsSection = regex.exec(content);
    while (commentsSection) {
        const valueRegex = regexs_utils_1.regexFactoryMap.markerValues(marker);
        // Get the rawKeys from the dynamic section
        const markers = commentsSection[0].match(valueRegex);
        commentsSection = regex.exec(content);
        if (!markers)
            continue;
        markers
            .map(stringToKeys(valueRegex))
            .reduce(flatten, [])
            .forEach((currentKey) => {
            const withRead = read ? `${read}.${currentKey}` : currentKey;
            let [translationKey, scopeAlias] = (0, resolvers_utils_1.resolveAliasAndKey)(withRead, baseParams.scopes);
            if (!scopeAlias) {
                // It means this is a global key
                translationKey = withRead;
            }
            (0, add_key_1.addKey)(Object.assign(Object.assign({}, baseParams), { keyWithoutScope: translationKey, scopeAlias }));
        });
    }
}
exports.addCommentSectionKeys = addCommentSectionKeys;
//# sourceMappingURL=add-comment-section-keys.js.map