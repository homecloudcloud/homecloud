"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.templateCommentsExtractor = void 0;
const cheerio_1 = __importDefault(require("cheerio"));
const config_1 = require("../../config");
const types_1 = require("../../types");
const file_utils_1 = require("../../utils/file.utils");
const regexs_utils_1 = require("../../utils/regexs.utils");
const add_comment_section_keys_1 = require("../add-comment-section-keys");
/**
 * We can't use AST here since the comments markings support the read property, and the AST extracts them without context
 * */
function templateCommentsExtractor({ file, scopes, defaultValue, scopeToKeys, }) {
    const { hasComments, content } = keepMarkingCommentsOnly((0, file_utils_1.readFile)(file));
    if (!hasComments)
        return scopeToKeys;
    const templateContainers = [];
    const baseParams = { defaultValue, scopes, scopeToKeys };
    const { containers, hasStructural } = getNgTemplateContainers(content);
    if (containers.length > 0) {
        const fileTemplate = hasStructural
            ? content.replace(/\*transloco/g, '__transloco')
            : content;
        const $ = loadCheerio(fileTemplate);
        for (const query of containers) {
            $(query).each((_, element) => {
                const containerType = !!element.attribs.__transloco
                    ? types_1.TEMPLATE_TYPE.STRUCTURAL
                    : types_1.TEMPLATE_TYPE.NG_TEMPLATE;
                templateContainers.push({
                    containerContent: $(element).html(),
                    read: extractReadValue(element, containerType),
                });
            });
        }
    }
    /** Add the global content to the containers array */
    templateContainers.push({ containerContent: loadCheerio(content).html() });
    templateContainers.forEach(({ containerContent, read }, _, arr) => {
        (0, add_comment_section_keys_1.addCommentSectionKeys)(Object.assign({ read, regexFactory: regexs_utils_1.regexFactoryMap.template.comments, content: removeInnerContainers(containerContent, arr) }, baseParams));
    });
    return scopeToKeys;
}
exports.templateCommentsExtractor = templateCommentsExtractor;
function getNgTemplateContainers(content) {
    const hasNgTemplate = content.match(/<ng-template[^>]*transloco[^>]*>/);
    const hasStructural = content.includes('*transloco');
    const containers = [];
    if (hasNgTemplate)
        containers.push('ng-template[transloco]');
    if (hasStructural)
        containers.push('[__transloco]');
    return {
        containers,
        hasStructural,
    };
}
function keepMarkingCommentsOnly(content) {
    const { marker } = (0, config_1.getConfig)();
    const validMarking = regexs_utils_1.regexFactoryMap.template.validateComment(marker);
    let hasComments = false;
    return {
        /* Search all comments, if they include anything but the markings remove them */
        content: content.replace(regexs_utils_1.regexFactoryMap.template.comments(), (comment) => {
            if (validMarking.test(comment)) {
                hasComments = true;
                return comment;
            }
            return '';
        }),
        hasComments,
    };
}
function removeInnerContainers(content, allContainers) {
    return allContainers
        .filter(({ containerContent }) => content !== containerContent && content.includes(containerContent))
        .reduce((acc, { containerContent }) => acc.replace(containerContent, ''), content);
}
function loadCheerio(content) {
    return cheerio_1.default.load(content, { decodeEntities: false });
}
/** Get the read value from an ngTemplate/ngContainer element */
function extractReadValue(element, templateType) {
    let read;
    if (templateType === types_1.TEMPLATE_TYPE.STRUCTURAL) {
        const data = element.attribs.__transloco;
        const readSearch = data.match(/read:\s*(['"])(?<read>[^"']*)\1/);
        read = readSearch === null || readSearch === void 0 ? void 0 : readSearch.groups.read;
    }
    if (templateType === types_1.TEMPLATE_TYPE.NG_TEMPLATE) {
        const attrs = Object.keys(element.attribs);
        const readSearch = attrs.find((attr) => ['translocoread', '[translocoread]'].includes(attr));
        read = readSearch && element.attribs[readSearch].replace(/['"]/g, '');
    }
    return read;
}
//# sourceMappingURL=comments.extractor.js.map