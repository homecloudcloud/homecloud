"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.directiveExtractor = void 0;
const compiler_1 = require("@angular/compiler");
const add_key_1 = require("../add-key");
const resolvers_utils_1 = require("../utils/resolvers.utils");
const utils_1 = require("./utils");
function directiveExtractor(config) {
    const ast = (0, utils_1.parseTemplate)(config);
    traverse(ast.nodes, config);
}
exports.directiveExtractor = directiveExtractor;
function traverse(nodes, config) {
    for (const node of nodes) {
        if (!(0, utils_1.isSupportedNode)(node, [utils_1.isTemplate, utils_1.isElement])) {
            continue;
        }
        const astTrees = [...node.inputs, ...node.attributes]
            .filter(isTranslocoDirective)
            .map((ast) => {
            let value = ast.value;
            if (value instanceof compiler_1.ASTWithSource) {
                value = value.ast;
            }
            return (0, utils_1.isInterpolation)(value) ? value.expressions : value;
        })
            .flat();
        traverse(node.children, config);
        addKeysFromAst(astTrees, config);
    }
}
function isTranslocoDirective(ast) {
    return (((0, utils_1.isBoundAttribute)(ast) || (0, utils_1.isTextAttribute)(ast)) && ast.name === 'transloco');
}
function addKeysFromAst(expressions, config) {
    for (const exp of expressions) {
        const isString = typeof exp === 'string';
        if ((0, utils_1.isConditionalExpression)(exp)) {
            addKeysFromAst([exp.trueExp, exp.falseExp], config);
        }
        else if ((0, utils_1.isLiteralExpression)(exp) || isString) {
            const [key, scopeAlias] = (0, resolvers_utils_1.resolveAliasAndKey)(isString ? exp : exp.value, config.scopes);
            (0, add_key_1.addKey)(Object.assign(Object.assign({}, config), { keyWithoutScope: key, scopeAlias }));
        }
    }
}
//# sourceMappingURL=directive.extractor.js.map