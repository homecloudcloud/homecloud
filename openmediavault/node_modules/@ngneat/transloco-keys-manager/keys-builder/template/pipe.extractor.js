"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pipeExtractor = void 0;
const add_key_1 = require("../add-key");
const resolvers_utils_1 = require("../utils/resolvers.utils");
const utils_1 = require("./utils");
function pipeExtractor(config) {
    const ast = (0, utils_1.parseTemplate)(config);
    traverse(ast.nodes, config);
}
exports.pipeExtractor = pipeExtractor;
function traverse(nodes, config) {
    for (const node of nodes) {
        let astTrees = [];
        if ((0, utils_1.isElement)(node) || (0, utils_1.isTemplate)(node)) {
            astTrees = node.inputs.map((input) => input.value.ast);
            traverse(node.children, config);
        }
        else if ((0, utils_1.isBoundText)(node)) {
            astTrees = [node.value.ast];
        }
        for (const ast of astTrees) {
            addKeysFromAst(getPipeValuesFromAst(ast), config);
        }
    }
}
function isTranslocoPipe(ast) {
    const isPipeChaining = (0, utils_1.isBindingPipe)(ast.exp);
    const isTransloco = ast.name === 'transloco' &&
        (isPipeChaining ||
            (0, utils_1.isLiteralExpression)(ast.exp) ||
            (0, utils_1.isConditionalExpression)(ast.exp));
    return isTransloco || (isPipeChaining && isTranslocoPipe(ast.exp));
}
function getPipeValuesFromAst(ast) {
    let exp = [];
    if ((0, utils_1.isBindingPipe)(ast) && isTranslocoPipe(ast)) {
        if ((0, utils_1.isLiteralExpression)(ast.exp)) {
            return [ast.exp];
        }
        else if ((0, utils_1.isConditionalExpression)(ast.exp)) {
            return [ast.exp.trueExp, ast.exp.falseExp];
        }
        else {
            let pipe = ast;
            while ((0, utils_1.isBindingPipe)(pipe.exp)) {
                pipe = pipe.exp;
            }
            return [pipe.exp];
        }
    }
    else if ((0, utils_1.isBindingPipe)(ast)) {
        exp = [...ast.args, ast.exp];
    }
    else if ((0, utils_1.isLiteralMap)(ast)) {
        exp = ast.values;
    }
    else if ((0, utils_1.isInterpolation)(ast)) {
        exp = ast.expressions;
    }
    else if ((0, utils_1.isConditionalExpression)(ast)) {
        exp = [ast.condition, ast.trueExp, ast.falseExp];
    }
    else if ((0, utils_1.isBinaryExpression)(ast)) {
        exp = [ast.left, ast.right];
    }
    else if ((0, utils_1.isMethodCall)(ast)) {
        exp = [...ast.args, ast.receiver];
    }
    return exp.map(getPipeValuesFromAst).flat();
}
function addKeysFromAst(expressions, config) {
    for (const exp of expressions) {
        if ((0, utils_1.isConditionalExpression)(exp)) {
            addKeysFromAst([exp.trueExp, exp.falseExp], config);
        }
        else if ((0, utils_1.isLiteralExpression)(exp)) {
            const [key, scopeAlias] = (0, resolvers_utils_1.resolveAliasAndKey)(exp.value, config.scopes);
            (0, add_key_1.addKey)(Object.assign(Object.assign({}, config), { keyWithoutScope: key, scopeAlias }));
        }
    }
}
//# sourceMappingURL=pipe.extractor.js.map