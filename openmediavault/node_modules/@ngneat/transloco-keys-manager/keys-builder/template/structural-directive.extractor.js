"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.structuralDirectiveExtractor = void 0;
const compiler_1 = require("@angular/compiler");
const add_key_1 = require("../add-key");
const resolvers_utils_1 = require("../utils/resolvers.utils");
const utils_1 = require("./utils");
function structuralDirectiveExtractor(config) {
    const ast = (0, utils_1.parseTemplate)(config);
    traverse(ast.nodes, [], config);
}
exports.structuralDirectiveExtractor = structuralDirectiveExtractor;
function traverse(nodes, containers, config) {
    for (const node of nodes) {
        let methodUsages = [];
        if ((0, utils_1.isBoundText)(node)) {
            const { expressions } = node.value
                .ast;
            methodUsages = getMethodUsages(expressions, containers);
        }
        else if ((0, utils_1.isSupportedNode)(node, [utils_1.isTemplate, utils_1.isElement])) {
            if (isTranslocoTemplate(node)) {
                for (const metadata of resolveMetadata(node)) {
                    containers.push(metadata);
                }
            }
            let attrsSource = node.inputs;
            if ((0, utils_1.isTemplate)(node)) {
                attrsSource = node.inputs.concat(node.templateAttrs.filter(utils_1.isBoundAttribute));
            }
            const boundAttrs = attrsSource
                .map((input) => {
                const { ast } = input.value;
                return (0, utils_1.isInterpolation)(ast) ? ast.expressions : ast;
            })
                .flat();
            methodUsages = getMethodUsages(boundAttrs, containers);
            traverse(node.children, containers, config);
        }
        addKeysFromAst(methodUsages, config);
    }
}
exports.traverse = traverse;
class MethodCallUnwrapper extends compiler_1.RecursiveAstVisitor {
    constructor() {
        super(...arguments);
        this.expressions = [];
    }
    visitMethodCall(method, context) {
        this.expressions.push(method);
        super.visitMethodCall(method, context);
    }
}
/**
 * Extract method calls from an AST.
 */
function unwrapMethodCalls(exp) {
    const unwrapper = new MethodCallUnwrapper();
    unwrapper.visit(exp);
    return unwrapper.expressions;
}
function getMethodUsages(expressions, containers) {
    return expressions
        .flatMap(unwrapMethodCalls)
        .filter((exp) => isTranslocoMethod(exp, containers))
        .map((exp) => {
        return Object.assign({ exp: exp.args[0] }, containers.find(({ name, spanOffset: { start, end } }) => {
            const inRange = exp.sourceSpan.end < end && exp.sourceSpan.start > start;
            return exp.name === name && inRange;
        }));
    });
}
function isTranslocoAttr(attr) {
    return attr.name === 'transloco';
}
function isReadAttr(attr) {
    return attr.name === 'translocoRead';
}
function isTranslocoTemplate(node) {
    return ((0, utils_1.isTemplate)(node) &&
        (node.templateAttrs.some(isTranslocoAttr) ||
            ((0, utils_1.isNgTemplateTag)(node) && node.attributes.some(isTranslocoAttr))));
}
function isTranslocoMethod(exp, containers) {
    return (0, utils_1.isMethodCall)(exp) && containers.some(({ name }) => name === exp.name);
}
function resolveMetadata(node) {
    var _a, _b, _c, _d;
    /*
     * An ngTemplate element might have more then once implicit variables, we need to capture all of them.
     * */
    let metadata;
    if ((0, utils_1.isNgTemplateTag)(node)) {
        const implicitVars = node.variables.filter((attr) => !attr.value);
        let read = (_a = node.attributes.find(isReadAttr)) === null || _a === void 0 ? void 0 : _a.value;
        if (!read) {
            const ast = (_c = (_b = node.inputs.find(isReadAttr)) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.ast;
            if ((0, utils_1.isLiteralExpression)(ast)) {
                read = ast.value;
            }
        }
        metadata = implicitVars.map(({ name }) => ({ name, read }));
    }
    else {
        const { name } = node.variables.find((variable) => variable.value === '$implicit');
        const read = (_d = node.templateAttrs.find(isReadAttr)) === null || _d === void 0 ? void 0 : _d.value;
        metadata = (0, utils_1.isLiteralExpression)(read === null || read === void 0 ? void 0 : read.ast)
            ? [{ name, read: read.ast.value }]
            : [{ name }];
    }
    return metadata.map((metadata) => {
        const sourceSpan = node.sourceSpan;
        return Object.assign(Object.assign({}, metadata), { spanOffset: {
                start: sourceSpan.start.offset,
                end: sourceSpan.end.offset,
            } });
    });
}
function addKeysFromAst(expressions, config) {
    for (const { exp, read } of expressions) {
        if ((0, utils_1.isConditionalExpression)(exp)) {
            for (const conditionValue of [exp.trueExp, exp.falseExp]) {
                addKeysFromAst([{ exp: conditionValue, read }], config);
            }
        }
        else if ((0, utils_1.isLiteralExpression)(exp) && exp.value) {
            let value = read ? `${read}.${exp.value}` : exp.value;
            const [key, scopeAlias] = (0, resolvers_utils_1.resolveAliasAndKey)(value, config.scopes);
            (0, add_key_1.addKey)(Object.assign(Object.assign({}, config), { keyWithoutScope: key, scopeAlias }));
        }
    }
}
//# sourceMappingURL=structural-directive.extractor.js.map