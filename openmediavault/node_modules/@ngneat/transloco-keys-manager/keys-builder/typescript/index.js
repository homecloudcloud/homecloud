"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractTSKeys = void 0;
const tsquery_1 = require("@phenomnomnominal/tsquery");
const file_utils_1 = require("../../utils/file.utils");
const regexs_utils_1 = require("../../utils/regexs.utils");
const add_comment_section_keys_1 = require("../add-comment-section-keys");
const add_key_1 = require("../add-key");
const extract_keys_1 = require("../utils/extract-keys");
const resolvers_utils_1 = require("../utils/resolvers.utils");
const inline_template_1 = require("./inline-template");
const marker_extractor_1 = require("./marker.extractor");
const pure_function_extractor_1 = require("./pure-function.extractor");
const service_extractor_1 = require("./service.extractor");
function extractTSKeys(config) {
    return (0, extract_keys_1.extractKeys)(config, 'ts', TSExtractor);
}
exports.extractTSKeys = extractTSKeys;
function TSExtractor(config) {
    const { file, scopes, defaultValue, scopeToKeys } = config;
    const content = (0, file_utils_1.readFile)(file);
    const extractors = [];
    if (content.includes('@ngneat/transloco')) {
        extractors.push(service_extractor_1.serviceExtractor, pure_function_extractor_1.pureFunctionExtractor);
    }
    if (content.includes('@ngneat/transloco-keys-manager')) {
        extractors.push(marker_extractor_1.markerExtractor);
    }
    const ast = tsquery_1.tsquery.ast(content);
    const baseParams = {
        scopeToKeys,
        scopes,
        defaultValue,
    };
    extractors
        .map((ex) => ex(ast))
        .flat()
        .forEach(({ key, lang }) => {
        const [keyWithoutScope, scopeAlias] = resolveAliasAndKeyFromService(key, lang, scopes);
        (0, add_key_1.addKey)(Object.assign({ scopeAlias,
            keyWithoutScope }, baseParams));
    });
    /** Check for dynamic markings */
    (0, add_comment_section_keys_1.addCommentSectionKeys)(Object.assign({ content, regexFactory: regexs_utils_1.regexFactoryMap.ts.comments }, baseParams));
    (0, inline_template_1.inlineTemplateExtractor)(ast, config);
    return scopeToKeys;
}
/**
 *
 * It can be one of the following:
 *
 * translate('2', {}, 'some/nested');
 * translate('3', {}, 'some/nested/en');
 * translate('globalKey');
 *
 */
function resolveAliasAndKeyFromService(key, scopePath, scopes) {
    // It means that it's the global
    if (!scopePath) {
        return [key, null];
    }
    const scopeAlias = (0, resolvers_utils_1.resolveScopeAlias)({ scopePath, scopes });
    return [key, scopeAlias];
}
//# sourceMappingURL=index.js.map