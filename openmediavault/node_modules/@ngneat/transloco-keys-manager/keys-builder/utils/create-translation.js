"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTranslation = void 0;
const flat_1 = require("flat");
const gettext_parser_1 = require("gettext-parser");
const config_1 = require("../../config");
const object_utils_1 = require("../../utils/object.utils");
const remove_extra_keys_1 = require("./remove-extra-keys");
function resolveTranslation({ currentTranslation, translation, replace, removeExtraKeys: removeExtraKeysParam, }) {
    if (replace) {
        return (0, object_utils_1.mergeDeep)({}, translation);
    }
    if (removeExtraKeysParam) {
        currentTranslation = (0, remove_extra_keys_1.removeExtraKeys)(currentTranslation, translation);
    }
    return (0, object_utils_1.mergeDeep)({}, translation, currentTranslation);
}
function createJson(config) {
    const { translation } = config;
    return (0, object_utils_1.stringify)(resolveTranslation(Object.assign(Object.assign({}, config), { translation: (0, config_1.getConfig)().unflat
            ? (0, flat_1.unflatten)(translation, { object: true })
            : translation })));
}
function createPot(config) {
    const resolved = (0, config_1.getConfig)().unflat
        ? (0, flat_1.flatten)(resolveTranslation(config))
        : resolveTranslation(config);
    return gettext_parser_1.po
        .compile({
        charset: 'utf-8',
        headers: {
            'mime-version': '1.0',
            'content-type': 'text/plain; charset=utf-8',
            'content-transfer-encoding': '8bit',
        },
        translations: {
            '': Object.entries(resolved).reduce((acc, [msgid, msgstr]) => (Object.assign(Object.assign({}, acc), { [msgid]: { msgid, msgstr } })), {}),
        },
    })
        .toString('utf8');
}
const compilers = {
    json: createJson,
    pot: createPot,
};
function createTranslation(config) {
    return compilers[config.fileFormat](config);
}
exports.createTranslation = createTranslation;
//# sourceMappingURL=create-translation.js.map