"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareKeysToFiles = void 0;
const transloco_utils_1 = require("@ngneat/transloco-utils");
const deep_diff_1 = require("deep-diff");
const flat_1 = require("flat");
const messages_1 = require("../messages");
const file_utils_1 = require("../utils/file.utils");
const logger_1 = require("../utils/logger");
const path_utils_1 = require("../utils/path.utils");
const build_table_1 = require("./build-table");
const get_translation_files_path_1 = require("./get-translation-files-path");
const normalize_glob_path_1 = require("../utils/normalize-glob-path");
function compareKeysToFiles({ scopeToKeys, translationsPath, addMissingKeys, emitErrorOnExtraKeys, fileFormat, }) {
    const logger = (0, logger_1.getLogger)();
    logger.startSpinner(`${messages_1.messages.checkMissing} ✨`);
    const diffsPerLang = {};
    /** An array of the existing translation files paths */
    const translationFiles = (0, get_translation_files_path_1.getTranslationFilesPath)(translationsPath, fileFormat);
    let result = [];
    const scopePaths = (0, transloco_utils_1.getGlobalConfig)().scopePathMap || {};
    for (const [scope, path] of Object.entries(scopePaths)) {
        const keys = scopeToKeys[scope];
        if (keys) {
            const res = {
                keys,
                scope,
                baseFilesPath: path,
            };
            result.push(Object.assign(Object.assign({}, res), { files: (0, normalize_glob_path_1.normalizedGlob)(`${res.baseFilesPath}/*.${fileFormat}`) }));
        }
    }
    const cache = {};
    for (const filePath of translationFiles) {
        const { scope = '__global' } = (0, path_utils_1.getScopeAndLangFromPath)({
            filePath,
            translationsPath,
            fileFormat,
        });
        if (cache[scope]) {
            continue;
        }
        cache[scope] = true;
        const keys = scope ? scopeToKeys[scope] : scopeToKeys.__global;
        if (keys) {
            const isGlobal = scope === '__global';
            const res = {
                keys,
                scope,
                baseFilesPath: translationsPath,
            };
            result.push(Object.assign(Object.assign({}, res), { files: (0, normalize_glob_path_1.normalizedGlob)(`${res.baseFilesPath}/${isGlobal ? '' : scope}/*.${fileFormat}`) }));
        }
    }
    for (const { files, keys, scope, baseFilesPath } of result) {
        for (const filePath of files) {
            const { lang } = (0, path_utils_1.getScopeAndLangFromPath)({
                filePath,
                translationsPath: baseFilesPath,
                fileFormat,
            });
            const translation = (0, file_utils_1.readFile)(filePath, { parse: true });
            // We always build the keys flatten, so we need to make sure we compare to a flat file
            const flat = (0, flat_1.flatten)(translation, {
                safe: true,
            });
            // Compare the current file with the extracted keys
            const differences = (0, deep_diff_1.diff)(flat, keys);
            if (differences) {
                const langPath = `${scope !== '__global' ? scope + '/' : ''}${lang}`;
                diffsPerLang[langPath] = {
                    missing: [],
                    extra: [],
                };
                for (const diff of differences) {
                    if (diff.kind === 'N') {
                        diffsPerLang[langPath].missing.push(diff);
                        addMissingKeys && (0, deep_diff_1.applyChange)(translation, keys, diff);
                    }
                    else if (diff.kind === 'D') {
                        const isComment = diff.path.join('.').endsWith('.comment');
                        !isComment && diffsPerLang[langPath].extra.push(diff);
                    }
                }
                addMissingKeys && (0, file_utils_1.writeFile)(filePath, translation);
            }
        }
    }
    logger.success(`${messages_1.messages.checkMissing} ✨`);
    const langs = Object.keys(diffsPerLang).filter((lang) => {
        const { missing, extra } = diffsPerLang[lang];
        return missing.length || extra.length;
    });
    (0, build_table_1.buildTable)({
        langs,
        diffsPerLang,
        addMissingKeys,
        emitErrorOnExtraKeys,
    });
}
exports.compareKeysToFiles = compareKeysToFiles;
//# sourceMappingURL=compare-keys-to-files.js.map