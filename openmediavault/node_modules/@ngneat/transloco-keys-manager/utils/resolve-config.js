"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConfig = void 0;
const transloco_utils_1 = require("@ngneat/transloco-utils");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const config_1 = require("../config");
const scope_utils_1 = require("../keys-builder/utils/scope.utils");
const messages_1 = require("../messages");
const logger_1 = require("./logger");
const path_utils_1 = require("./path.utils");
const resolve_project_base_path_1 = require("./resolve-project-base-path");
const update_scopes_map_1 = require("./update-scopes-map");
const validators_utils_1 = require("./validators.utils");
function resolveConfig(inlineConfig) {
    const { projectBasePath, projectType } = (0, resolve_project_base_path_1.resolveProjectBasePath)(inlineConfig.project);
    const defaults = (0, config_1.defaultConfig)(projectType);
    const fileConfig = (0, transloco_utils_1.getGlobalConfig)(inlineConfig.config || projectBasePath);
    const userConfig = Object.assign(Object.assign({}, flatFileConfig(fileConfig)), inlineConfig);
    const config = Object.assign(Object.assign({}, defaults), userConfig);
    (0, logger_1.devlog)('config', 'Config', {
        Default: defaults,
        'Transloco file': flatFileConfig(fileConfig),
        Inline: inlineConfig,
        Merged: config,
    });
    (0, path_utils_1.resolveConfigPaths)(config, projectBasePath);
    validateDirectories(config);
    (0, logger_1.devlog)('paths', 'Configuration Paths', {
        Input: config.input,
        Output: config.output,
        Translations: config.translationsPath,
    });
    (0, update_scopes_map_1.updateScopesMap)({ input: config.input });
    (0, logger_1.devlog)('scopes', 'Scopes', {
        'Scopes map': (0, scope_utils_1.getScopes)().scopeToAlias,
    });
    return Object.assign(Object.assign({}, config), { scopes: (0, scope_utils_1.getScopes)() });
}
exports.resolveConfig = resolveConfig;
function flatFileConfig(fileConfig) {
    const keysManager = fileConfig.keysManager || {};
    const { rootTranslationsPath, langs, scopePathMap } = fileConfig;
    if (keysManager.input) {
        keysManager.input = Array.isArray(keysManager.input)
            ? keysManager.input
            : keysManager.input.split(',');
    }
    const config = Object.assign({}, keysManager);
    if (rootTranslationsPath) {
        config.translationsPath = rootTranslationsPath;
    }
    if (langs) {
        config.langs = langs;
    }
    if (scopePathMap) {
        config.scopePathMap = scopePathMap;
    }
    return config;
}
function validateDirectories({ input, translationsPath, command }) {
    let invalidPath = false;
    const log = (path, prop) => {
        const msg = (0, fs_1.existsSync)(path)
            ? messages_1.messages.pathIsNotDir
            : messages_1.messages.pathDoesntExist;
        console.log(chalk_1.default.bgRed.black(`${prop} ${msg}`));
    };
    for (const path of input) {
        if (!(0, validators_utils_1.isDirectory)(path)) {
            invalidPath = true;
            log(path, 'Input');
        }
    }
    if (command === 'find' && !(0, validators_utils_1.isDirectory)(translationsPath)) {
        invalidPath = true;
        log(translationsPath, 'Translations');
    }
    invalidPath && process.exit();
}
//# sourceMappingURL=resolve-config.js.map