"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateScopesMap = void 0;
const tsquery_1 = require("@phenomnomnominal/tsquery");
const scope_utils_1 = require("../keys-builder/utils/scope.utils");
const collection_utils_1 = require("./collection.utils");
const file_utils_1 = require("./file.utils");
const string_utils_1 = require("./string.utils");
const normalize_glob_path_1 = require("./normalize-glob-path");
const baseQuery = `ObjectLiteralExpression:has(PropertyAssignment > Identifier[name=TRANSLOCO_SCOPE]) PropertyAssignment:has(Identifier[name=/useValue|useFactory/])`;
const stringQueryDef = {
    query: `StringLiteral`,
    resolver: ([node]) => ({ scope: node.text }),
};
const objectQueryDef = {
    query: 'ObjectLiteralExpression',
    resolver: ([node]) => {
        let result = {};
        for (const prop of node.properties) {
            if (prop.initializer) {
                const key = prop.name.getText();
                if (key === 'scope' || key === 'alias') {
                    result[key] = prop.initializer.getText().replace(/['"]/g, '');
                }
            }
        }
        return result;
    },
};
const arrayQueryDef = {
    query: 'ArrayLiteralExpression > StringLiteral',
    resolver: (nodes) => nodes.map((node) => ({ scope: node.text })),
};
const scopeValueQueries = [
    stringQueryDef,
    objectQueryDef,
    arrayQueryDef,
];
function updateScopesMap({ input, files, }) {
    const tsFiles = files || input.map((path) => (0, normalize_glob_path_1.normalizedGlob)(`${path}/**/*.ts`)).flat();
    // Return only the new scopes (for the plugin)
    const aliasToScope = {};
    for (const file of tsFiles) {
        const content = (0, file_utils_1.readFile)(file);
        if (!content.includes('TRANSLOCO_SCOPE'))
            continue;
        let result;
        const ast = tsquery_1.tsquery.ast(content);
        for (const { query, resolver } of scopeValueQueries) {
            const nodes = (0, tsquery_1.tsquery)(ast, `${baseQuery} > ${query}`);
            if (nodes.length > 0) {
                result = resolver(nodes);
                break;
            }
        }
        for (let { scope, alias } of (0, collection_utils_1.coerceArray)(result)) {
            if (scope && (0, scope_utils_1.hasScope)(scope) === false) {
                if (!alias) {
                    alias = (0, string_utils_1.toCamelCase)(scope);
                }
                (0, scope_utils_1.addScope)(scope, alias);
                aliasToScope[alias] = scope;
            }
        }
    }
    return aliasToScope;
}
exports.updateScopesMap = updateScopesMap;
//# sourceMappingURL=update-scopes-map.js.map