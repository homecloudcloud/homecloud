import { Directive } from '@angular/core';
import { fromEvent, merge, Observable } from 'rxjs';
import { map, switchMap, takeUntil, tap } from 'rxjs/operators';
import { stopPropagation } from './scrollbar/common';
import * as i0 from "@angular/core";
export class ScrollViewport {
    constructor(viewPort) {
        this.viewPort = viewPort;
        this.nativeElement = viewPort.nativeElement;
    }
    // Get viewport size, clientHeight or clientWidth
    get clientHeight() {
        return this.nativeElement.clientHeight;
    }
    get clientWidth() {
        return this.nativeElement.clientWidth;
    }
    get scrollHeight() {
        return this.nativeElement.scrollHeight;
    }
    get scrollWidth() {
        return this.nativeElement.scrollWidth;
    }
    // Get viewport scroll offset, scrollTop or scrollLeft
    get scrollTop() {
        return this.nativeElement.scrollTop;
    }
    get scrollLeft() {
        return this.nativeElement.scrollLeft;
    }
    // Get the available scrollable size
    get scrollMaxX() {
        return this.scrollWidth - this.clientWidth;
    }
    get scrollMaxY() {
        return this.scrollHeight - this.clientHeight;
    }
    get contentHeight() {
        return this.contentWrapperElement?.clientHeight || 0;
    }
    get contentWidth() {
        return this.contentWrapperElement?.clientWidth || 0;
    }
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     */
    activatePointerEvents(propagate, destroyed) {
        this.hovered = new Observable((subscriber) => {
            // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
            const mouseMoveStream = fromEvent(this.nativeElement, 'mousemove', { passive: true });
            const mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation());
            // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
            const mouseLeave = fromEvent(this.nativeElement, 'mouseleave', { passive: true }).pipe(map(() => false));
            merge(mouseMove, mouseLeave).pipe(tap((e) => subscriber.next(e)), takeUntil(destroyed)).subscribe();
        });
        this.clicked = new Observable((subscriber) => {
            const mouseDown = fromEvent(this.nativeElement, 'mousedown', { passive: true }).pipe(tap((e) => subscriber.next(e)));
            const mouseUp = fromEvent(this.nativeElement, 'mouseup', { passive: true }).pipe(tap(() => subscriber.next(false)));
            mouseDown.pipe(switchMap(() => mouseUp), takeUntil(destroyed)).subscribe();
        });
    }
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     */
    setAsWrapper() {
        // In this case the default viewport and the default content wrapper will act as a mask
        this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
        if (this.nativeElement.firstElementChild) {
            this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
    }
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     */
    setAsViewport(customClassName) {
        this.nativeElement.className = `ng-native-scrollbar-hider ng-scroll-viewport ${customClassName}`;
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.nativeElement.firstElementChild) {
            this.contentWrapperElement = this.nativeElement.firstElementChild;
            this.contentWrapperElement.classList.add('ng-scroll-content');
        }
    }
    /**
     * Scroll viewport vertically
     */
    scrollYTo(value) {
        this.nativeElement.scrollTop = value;
    }
    /**
     * Scroll viewport horizontally
     */
    scrollXTo(value) {
        this.nativeElement.scrollLeft = value;
    }
}
ScrollViewport.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ScrollViewport, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
ScrollViewport.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.1.1", type: ScrollViewport, selector: "[scrollViewport]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ScrollViewport, decorators: [{
            type: Directive,
            args: [{
                    selector: '[scrollViewport]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXZpZXdwb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zcmMvbGliL3Njcm9sbC12aWV3cG9ydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFjLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUNoRSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQUtyRCxNQUFNLE9BQU8sY0FBYztJQXNEekIsWUFBbUIsUUFBb0I7UUFBcEIsYUFBUSxHQUFSLFFBQVEsQ0FBWTtRQUNyQyxJQUFJLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUM7SUFDOUMsQ0FBQztJQTdDRCxpREFBaUQ7SUFDakQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsc0RBQXNEO0lBQ3RELElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUM7SUFDdEMsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxV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Q0gsYUFBYSxDQUFDLGVBQXVCO1FBQ25DLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLGdEQUFnRCxlQUFlLEVBQUUsQ0FBQztRQUNqRyxvRkFBb0Y7UUFDcEYsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFO1lBQ3hDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFnQyxDQUFDO1lBQ2pGLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDL0Q7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTLENBQUMsS0FBYTtRQUNyQixJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDdkMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsU0FBUyxDQUFDLEtBQWE7UUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO0lBQ3hDLENBQUM7OzJHQTNIVSxjQUFjOytGQUFkLGNBQWM7MkZBQWQsY0FBYztrQkFIMUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsa0JBQWtCO2lCQUM3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBPYnNlcnZhYmxlLCBTdWJzY3JpYmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgc3dpdGNoTWFwLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgc3RvcFByb3BhZ2F0aW9uIH0gZnJvbSAnLi9zY3JvbGxiYXIvY29tbW9uJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW3Njcm9sbFZpZXdwb3J0XSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFNjcm9sbFZpZXdwb3J0IHtcclxuICAvLyBWaWV3cG9ydCBlbGVtZW50XHJcbiAgcmVhZG9ubHkgbmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcbiAgLy8gQ29udGVudCB3cmFwcGVyIGVsZW1lbnRcclxuICBjb250ZW50V3JhcHBlckVsZW1lbnQhOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBwb2ludGVyIGV2ZW50IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGhvdmVyZWQgYW5kIGVtaXRzIGZhbHNlIHZhbHVlIHdoZW4gaXNuJ3QgaG92ZXJlZFxyXG4gIGhvdmVyZWQhOiBPYnNlcnZhYmxlPE1vdXNlRXZlbnQgfCBmYWxzZT47XHJcbiAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiB2aWV3cG9ydCBpcyBjbGlja2VkXHJcbiAgY2xpY2tlZCE6IE9ic2VydmFibGU8TW91c2VFdmVudCB8IGZhbHNlPjtcclxuXHJcbiAgLy8gR2V0IHZpZXdwb3J0IHNpemUsIGNsaWVudEhlaWdodCBvciBjbGllbnRXaWR0aFxyXG4gIGdldCBjbGllbnRIZWlnaHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNsaWVudFdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNjcm9sbEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBnZXQgc2Nyb2xsV2lkdGgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGg7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdmlld3BvcnQgc2Nyb2xsIG9mZnNldCwgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnRcclxuICBnZXQgc2Nyb2xsVG9wKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcclxuICB9XHJcblxyXG4gIGdldCBzY3JvbGxMZWZ0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbExlZnQ7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdGhlIGF2YWlsYWJsZSBzY3JvbGxhYmxlIHNpemVcclxuICBnZXQgc2Nyb2xsTWF4WCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsV2lkdGggLSB0aGlzLmNsaWVudFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNjcm9sbE1heFkoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodCAtIHRoaXMuY2xpZW50SGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IGNvbnRlbnRIZWlnaHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRXcmFwcGVyRWxlbWVudD8uY2xpZW50SGVpZ2h0IHx8IDA7XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudFdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250ZW50V3JhcHBlckVsZW1lbnQ/LmNsaWVudFdpZHRoIHx8IDA7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWYpIHtcclxuICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IHZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBY3RpdmF0ZSB2aWV3cG9ydCBwb2ludGVyIGV2ZW50cyBzdWNoIGFzICdob3ZlcmVkJyBhbmQgJ2NsaWNrZWQnIGV2ZW50c1xyXG4gICAqL1xyXG4gIGFjdGl2YXRlUG9pbnRlckV2ZW50cyhwcm9wYWdhdGU6IGJvb2xlYW4sIGRlc3Ryb3llZDogT2JzZXJ2YWJsZTx2b2lkPik6IHZvaWQge1xyXG4gICAgdGhpcy5ob3ZlcmVkID0gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8TW91c2VFdmVudCB8IGZhbHNlPikgPT4ge1xyXG4gICAgICAvLyBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHBvaW50ZXIgaXMgbW92ZWQgb3ZlciB0aGUgdmlld3BvcnQgKHVzZWQgdG8gc2V0IHRoZSBob3ZlcmVkIHN0YXRlKVxyXG4gICAgICBjb25zdCBtb3VzZU1vdmVTdHJlYW0gPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5uYXRpdmVFbGVtZW50LCAnbW91c2Vtb3ZlJywgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICBjb25zdCBtb3VzZU1vdmUgPSBwcm9wYWdhdGUgPyBtb3VzZU1vdmVTdHJlYW0gOiBtb3VzZU1vdmVTdHJlYW0ucGlwZShzdG9wUHJvcGFnYXRpb24oKSk7XHJcbiAgICAgIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gcG9pbnRlciBsZWF2ZXMgdGhlIHZpZXdwb3J0ICh1c2VkIHRvIHJlbW92ZSB0aGUgaG92ZXJlZCBzdGF0ZSlcclxuICAgICAgY29uc3QgbW91c2VMZWF2ZSA9IGZyb21FdmVudDxmYWxzZT4odGhpcy5uYXRpdmVFbGVtZW50LCAnbW91c2VsZWF2ZScsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKG1hcCgoKSA9PiBmYWxzZSkpO1xyXG4gICAgICBtZXJnZShtb3VzZU1vdmUsIG1vdXNlTGVhdmUpLnBpcGUoXHJcbiAgICAgICAgdGFwKChlOiBNb3VzZUV2ZW50IHwgZmFsc2UpID0+IHN1YnNjcmliZXIubmV4dChlKSksXHJcbiAgICAgICAgdGFrZVVudGlsKGRlc3Ryb3llZClcclxuICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY2xpY2tlZCA9IG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPE1vdXNlRXZlbnQgfCBmYWxzZT4pID0+IHtcclxuICAgICAgY29uc3QgbW91c2VEb3duID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ21vdXNlZG93bicsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxyXG4gICAgICAgIHRhcCgoZTogTW91c2VFdmVudCkgPT4gc3Vic2NyaWJlci5uZXh0KGUpKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBtb3VzZVVwID0gZnJvbUV2ZW50PGZhbHNlPih0aGlzLm5hdGl2ZUVsZW1lbnQsICdtb3VzZXVwJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgICAgdGFwKCgpID0+IHN1YnNjcmliZXIubmV4dChmYWxzZSkpXHJcbiAgICAgICk7XHJcbiAgICAgIG1vdXNlRG93bi5waXBlKFxyXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PiBtb3VzZVVwKSxcclxuICAgICAgICB0YWtlVW50aWwoZGVzdHJveWVkKVxyXG4gICAgICApLnN1YnNjcmliZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhpcyBkaXJlY3RpdmUgYXMgYSBub24tZnVuY3Rpb25hbCB3cmFwcGVyLCBjYWxsZWQgd2hlbiBhIGN1c3RvbSB2aWV3cG9ydCBpcyB1c2VkXHJcbiAgICovXHJcbiAgc2V0QXNXcmFwcGVyKCk6IHZvaWQge1xyXG4gICAgLy8gSW4gdGhpcyBjYXNlIHRoZSBkZWZhdWx0IHZpZXdwb3J0IGFuZCB0aGUgZGVmYXVsdCBjb250ZW50IHdyYXBwZXIgd2lsbCBhY3QgYXMgYSBtYXNrXHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lID0gJ25nLW5hdGl2ZS1zY3JvbGxiYXItaGlkZXIgbmctc2Nyb2xsLWxheWVyJztcclxuICAgIGlmICh0aGlzLm5hdGl2ZUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcclxuICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTmFtZSA9ICduZy1zY3JvbGwtbGF5ZXInO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoaXMgZGlyZWN0aXZlIGFzICB0aGUgdmlld3BvcnQsIGNhbGxlZCB3aGVuIG5vIGN1c3RvbSB2aWV3cG9ydCBpcyB1c2VkXHJcbiAgICovXHJcbiAgc2V0QXNWaWV3cG9ydChjdXN0b21DbGFzc05hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9IGBuZy1uYXRpdmUtc2Nyb2xsYmFyLWhpZGVyIG5nLXNjcm9sbC12aWV3cG9ydCAke2N1c3RvbUNsYXNzTmFtZX1gO1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1c3RvbSB2aWV3cG9ydCBoYXMgb25seSBvbmUgY2hpbGQgYW5kIHNldCBpdCBhcyB0aGUgY29udGVudCB3cmFwcGVyXHJcbiAgICBpZiAodGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSB7XHJcbiAgICAgIHRoaXMuY29udGVudFdyYXBwZXJFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICB0aGlzLmNvbnRlbnRXcmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduZy1zY3JvbGwtY29udGVudCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHZpZXdwb3J0IHZlcnRpY2FsbHlcclxuICAgKi9cclxuICBzY3JvbGxZVG8odmFsdWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHZpZXdwb3J0IGhvcml6b250YWxseVxyXG4gICAqL1xyXG4gIHNjcm9sbFhUbyh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlO1xyXG4gIH1cclxufVxyXG4iXX0=