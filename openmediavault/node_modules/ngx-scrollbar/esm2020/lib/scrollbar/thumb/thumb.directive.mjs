import { Directive, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { ThumbAdapter } from './thumb';
import * as i0 from "@angular/core";
import * as i1 from "../../ng-scrollbar-base";
import * as i2 from "../track/track.directive";
import * as i3 from "@angular/cdk/bidi";
export class ThumbXDirective extends ThumbAdapter {
    constructor(cmp, track, element, document, dir) {
        super(cmp, track, element.nativeElement, document);
        this.cmp = cmp;
        this.track = track;
        this.element = element;
        this.document = document;
        this.dir = dir;
    }
    get clientProperty() {
        return 'clientX';
    }
    get pageProperty() {
        return 'pageX';
    }
    get viewportScrollSize() {
        return this.cmp.viewport.scrollWidth;
    }
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollLeft;
    }
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxX;
    }
    get dragStartOffset() {
        return this.clientRect.left + this.document.defaultView.pageXOffset || 0;
    }
    get size() {
        return this.thumbElement.clientWidth;
    }
    updateStyles(position, size) {
        this.thumbElement.style.width = `${size}px`;
        this.thumbElement.style.transform = `translate3d(${position}px, 0, 0)`;
    }
    handleDrag(position, scrollMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === 1 /* RtlScrollAxisType.NEGATED */) {
                return position - scrollMax;
            }
            if (this.cmp.manager.rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return scrollMax - position;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
            //   return position;
            // }
        }
        return position;
    }
    handleDirection(position, trackMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === 2 /* RtlScrollAxisType.INVERTED */) {
                return -position;
            }
            if (this.cmp.manager.rtlScrollAxisType === 0 /* RtlScrollAxisType.NORMAL */) {
                return position - trackMax;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
            //   return position;
            // }
        }
        return position;
    }
    setDragging(value) {
        this.cmp.setDragging({ horizontalDragging: value });
    }
    scrollTo(position) {
        this.cmp.viewport.scrollXTo(position);
    }
}
ThumbXDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ThumbXDirective, deps: [{ token: i1.NgScrollbarBase }, { token: i2.TrackXDirective }, { token: i0.ElementRef }, { token: DOCUMENT }, { token: i3.Directionality }], target: i0.ɵɵFactoryTarget.Directive });
ThumbXDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.1.1", type: ThumbXDirective, selector: "[scrollbarThumbX]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ThumbXDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[scrollbarThumbX]' }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbarBase }, { type: i2.TrackXDirective }, { type: i0.ElementRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i3.Directionality }]; } });
export class ThumbYDirective extends ThumbAdapter {
    constructor(cmp, track, element, document) {
        super(cmp, track, element.nativeElement, document);
        this.cmp = cmp;
        this.track = track;
        this.element = element;
        this.document = document;
    }
    get pageProperty() {
        return 'pageY';
    }
    get viewportScrollSize() {
        return this.cmp.viewport.scrollHeight;
    }
    get viewportScrollOffset() {
        return this.cmp.viewport.scrollTop;
    }
    get viewportScrollMax() {
        return this.cmp.viewport.scrollMaxY;
    }
    get clientProperty() {
        return 'clientY';
    }
    get dragStartOffset() {
        return this.clientRect.top + this.document.defaultView.pageYOffset || 0;
    }
    get size() {
        return this.thumbElement.clientHeight;
    }
    updateStyles(position, size) {
        this.thumbElement.style.height = `${size}px`;
        this.thumbElement.style.transform = `translate3d(0px, ${position}px, 0)`;
    }
    handleDrag(position) {
        return position;
    }
    handleDirection(position) {
        return position;
    }
    setDragging(value) {
        this.cmp.setDragging({ verticalDragging: value });
    }
    scrollTo(position) {
        this.cmp.viewport.scrollYTo(position);
    }
}
ThumbYDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ThumbYDirective, deps: [{ token: i1.NgScrollbarBase }, { token: i2.TrackYDirective }, { token: i0.ElementRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
ThumbYDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.1.1", type: ThumbYDirective, selector: "[scrollbarThumbY]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ThumbYDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[scrollbarThumbY]' }]
        }], ctorParameters: function () { return [{ type: i1.NgScrollbarBase }, { type: i2.TrackYDirective }, { type: i0.ElementRef }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGh1bWIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zcmMvbGliL3Njcm9sbGJhci90aHVtYi90aHVtYi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQWMsTUFBTSxlQUFlLENBQUM7QUFDOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7Ozs7O0FBS3ZDLE1BQU0sT0FBTyxlQUFnQixTQUFRLFlBQVk7SUE4Qi9DLFlBQXNCLEdBQW9CLEVBQ3BCLEtBQXNCLEVBQ3RCLE9BQW1CLEVBQ0QsUUFBa0IsRUFDcEMsR0FBbUI7UUFDdkMsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUwvQixRQUFHLEdBQUgsR0FBRyxDQUFpQjtRQUNwQixVQUFLLEdBQUwsS0FBSyxDQUFpQjtRQUN0QixZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ0QsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNwQyxRQUFHLEdBQUgsR0FBRyxDQUFnQjtJQUV6QyxDQUFDO0lBbENELElBQWMsY0FBYztRQUMxQixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsSUFBYyxZQUFZO1FBQ3hCLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxJQUFjLGtCQUFrQjtRQUM5QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUyxDQUFDLFdBQVcsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFBYyxvQkFBb0I7UUFDaEMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVMsQ0FBQyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELElBQUksaUJBQWlCO1FB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UyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7OzRHQXpEVSxlQUFlLDBHQWlDTixRQUFRO2dHQWpDakIsZUFBZTsyRkFBZixlQUFlO2tCQUQzQixTQUFTO21CQUFDLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixFQUFFOytJQWtDUSxRQUFROzBCQUE3QyxNQUFNOzJCQUFDLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEluamVjdCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IFJ0bFNjcm9sbEF4aXNUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcclxuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7IFRodW1iQWRhcHRlciB9IGZyb20gJy4vdGh1bWInO1xyXG5pbXBvcnQgeyBUcmFja1hEaXJlY3RpdmUsIFRyYWNrWURpcmVjdGl2ZSB9IGZyb20gJy4uL3RyYWNrL3RyYWNrLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IE5nU2Nyb2xsYmFyQmFzZSB9IGZyb20gJy4uLy4uL25nLXNjcm9sbGJhci1iYXNlJztcclxuXHJcbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tzY3JvbGxiYXJUaHVtYlhdJyB9KVxyXG5leHBvcnQgY2xhc3MgVGh1bWJYRGlyZWN0aXZlIGV4dGVuZHMgVGh1bWJBZGFwdGVyIHtcclxuXHJcbiAgcHJvdGVjdGVkIGdldCBjbGllbnRQcm9wZXJ0eSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICdjbGllbnRYJztcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgcGFnZVByb3BlcnR5KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gJ3BhZ2VYJztcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgdmlld3BvcnRTY3JvbGxTaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCB2aWV3cG9ydFNjcm9sbE9mZnNldCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wLnZpZXdwb3J0IS5zY3JvbGxMZWZ0O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHZpZXdwb3J0U2Nyb2xsTWF4KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbE1heFg7XHJcbiAgfVxyXG5cclxuICBnZXQgZHJhZ1N0YXJ0T2Zmc2V0KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0LmxlZnQgKyB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3IS5wYWdlWE9mZnNldCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnRodW1iRWxlbWVudC5jbGllbnRXaWR0aDtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBjbXA6IE5nU2Nyb2xsYmFyQmFzZSxcclxuICAgICAgICAgICAgICBwcm90ZWN0ZWQgdHJhY2s6IFRyYWNrWERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgICBwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcm90ZWN0ZWQgZG9jdW1lbnQ6IERvY3VtZW50LFxyXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBkaXI6IERpcmVjdGlvbmFsaXR5KSB7XHJcbiAgICBzdXBlcihjbXAsIHRyYWNrLCBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGRvY3VtZW50KTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCB1cGRhdGVTdHlsZXMocG9zaXRpb246IG51bWJlciwgc2l6ZTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnRodW1iRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3NpemV9cHhgO1xyXG4gICAgdGhpcy50aHVtYkVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7cG9zaXRpb259cHgsIDAsIDApYDtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBoYW5kbGVEcmFnKHBvc2l0aW9uOiBudW1iZXIsIHNjcm9sbE1heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmRpci52YWx1ZSA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHRoaXMuY21wLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQpIHtcclxuICAgICAgICByZXR1cm4gcG9zaXRpb24gLSBzY3JvbGxNYXg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuY21wLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjcm9sbE1heCAtIHBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEtlZXBpbmcgdGhpcyBhcyBhIG1lbW9cclxuICAgICAgLy8gaWYgKHRoaXMucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5PUk1BTCkge1xyXG4gICAgICAvLyAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGhhbmRsZURpcmVjdGlvbihwb3NpdGlvbjogbnVtYmVyLCB0cmFja01heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmRpci52YWx1ZSA9PT0gJ3J0bCcpIHtcclxuICAgICAgaWYgKHRoaXMuY21wLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIC1wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jbXAubWFuYWdlci5ydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTk9STUFMKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uIC0gdHJhY2tNYXg7XHJcbiAgICAgIH1cclxuICAgICAgLy8gS2VlcGluZyB0aGlzIGFzIGEgbWVtb1xyXG4gICAgICAvLyBpZiAodGhpcy5ydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xyXG4gICAgICAvLyAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNldERyYWdnaW5nKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLmNtcC5zZXREcmFnZ2luZyh7IGhvcml6b250YWxEcmFnZ2luZzogdmFsdWUgfSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocG9zaXRpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbFhUbyhwb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbc2Nyb2xsYmFyVGh1bWJZXScgfSlcclxuZXhwb3J0IGNsYXNzIFRodW1iWURpcmVjdGl2ZSBleHRlbmRzIFRodW1iQWRhcHRlciB7XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgcGFnZVByb3BlcnR5KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gJ3BhZ2VZJztcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgdmlld3BvcnRTY3JvbGxTaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbEhlaWdodDtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXQgdmlld3BvcnRTY3JvbGxPZmZzZXQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNtcC52aWV3cG9ydCEuc2Nyb2xsVG9wO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHZpZXdwb3J0U2Nyb2xsTWF4KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAudmlld3BvcnQhLnNjcm9sbE1heFk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IGNsaWVudFByb3BlcnR5KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gJ2NsaWVudFknO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRyYWdTdGFydE9mZnNldCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdC50b3AgKyB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3IS5wYWdlWU9mZnNldCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLnRodW1iRWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY21wOiBOZ1Njcm9sbGJhckJhc2UsXHJcbiAgICAgICAgICAgICAgcHJvdGVjdGVkIHRyYWNrOiBUcmFja1lEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgICAgcHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHJvdGVjdGVkIGRvY3VtZW50OiBEb2N1bWVudCkge1xyXG4gICAgc3VwZXIoY21wLCB0cmFjaywgZWxlbWVudC5uYXRpdmVFbGVtZW50LCBkb2N1bWVudCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgcHJvdGVjdGVkIHVwZGF0ZVN0eWxlcyhwb3NpdGlvbjogbnVtYmVyLCBzaXplOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMudGh1bWJFbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3NpemV9cHhgO1xyXG4gICAgdGhpcy50aHVtYkVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDBweCwgJHtwb3NpdGlvbn1weCwgMClgO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGhhbmRsZURyYWcocG9zaXRpb246IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgaGFuZGxlRGlyZWN0aW9uKHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNldERyYWdnaW5nKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLmNtcC5zZXREcmFnZ2luZyh7IHZlcnRpY2FsRHJhZ2dpbmc6IHZhbHVlIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNjcm9sbFRvKHBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMuY21wLnZpZXdwb3J0IS5zY3JvbGxZVG8ocG9zaXRpb24pO1xyXG4gIH1cclxufVxyXG4iXX0=