import { Output, Directive } from '@angular/core';
import { animationFrameScheduler, of, fromEvent, Subject } from 'rxjs';
import { distinctUntilChanged, map, mergeMap, pluck, takeUntil, tap } from 'rxjs/operators';
import { enableSelection, preventSelection, stopPropagation } from '../common';
import * as i0 from "@angular/core";
import * as i1 from "../../ng-scrollbar-base";
import * as i2 from "../track/track";
// @dynamic
export class ThumbAdapter {
    constructor(cmp, track, thumbElement, document) {
        this.cmp = cmp;
        this.track = track;
        this.thumbElement = thumbElement;
        this.document = document;
        // Stream that emits dragging state
        this._dragging = new Subject();
        this.dragging = this._dragging.pipe(distinctUntilChanged());
    }
    get trackMax() {
        return this.track.size - this.size;
    }
    // Get thumb client rect
    get clientRect() {
        return this.thumbElement.getBoundingClientRect();
    }
    // Stream that emits when scrollbar thumb is clicked
    get clicked() {
        return fromEvent(this.thumbElement, 'mousedown', { passive: true }).pipe(stopPropagation());
    }
    // Calculate and update thumb position and size
    update() {
        const size = calculateThumbSize(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize);
        const position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);
        animationFrameScheduler.schedule(() => this.updateStyles(this.handleDirection(position, this.trackMax), size));
    }
    /**
     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
     * This function is called by thumb drag event using viewport or scrollbar pointer events
     */
    dragged(event) {
        let trackMaxStart;
        let scrollMaxStart;
        const dragStart = of(event).pipe(preventSelection(this.document), tap(() => {
            // Capture scrollMax and trackMax once
            trackMaxStart = this.trackMax;
            scrollMaxStart = this.viewportScrollMax;
            this.setDragging(true);
        }));
        const dragging = fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(stopPropagation());
        const dragEnd = fromEvent(this.document, 'mouseup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging(false)));
        return dragStart.pipe(pluck(this.pageProperty), map((pageOffset) => pageOffset - this.dragStartOffset), mergeMap((mouseDownOffset) => dragging.pipe(pluck(this.clientProperty), 
        // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
        map((mouseOffset) => mouseOffset - this.track.offset), map((offset) => scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart), map((position) => this.handleDrag(position, scrollMaxStart)), tap((position) => this.scrollTo(position)), takeUntil(dragEnd))));
    }
}
ThumbAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ThumbAdapter, deps: [{ token: i1.NgScrollbarBase }, { token: i2.TrackAdapter }, { token: HTMLElement }, { token: Document }], target: i0.ɵɵFactoryTarget.Directive });
ThumbAdapter.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.1.1", type: ThumbAdapter, outputs: { dragging: "dragging" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.1", ngImport: i0, type: ThumbAdapter, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1.NgScrollbarBase }, { type: i2.TrackAdapter }, { type: HTMLElement }, { type: Document }]; }, propDecorators: { dragging: [{
                type: Output
            }] } });
/**
 * Calculate scrollbar thumb size
 */
function calculateThumbSize(trackSize, contentSize, minThumbSize) {
    const scrollbarRatio = trackSize / contentSize;
    const thumbSize = scrollbarRatio * trackSize;
    return Math.max(~~thumbSize, minThumbSize);
}
/**
 * Calculate scrollbar thumb position
 */
function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
    return scrollPosition * trackMax / scrollMax;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGh1bWIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc2Nyb2xsYmFyL3NyYy9saWIvc2Nyb2xsYmFyL3RodW1iL3RodW1iLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVGLE9BQU8sRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLE1BQU0sV0FBVyxDQUFDOzs7O0FBSS9FLFdBQVc7QUFFWCxNQUFNLE9BQWdCLFlBQVk7SUFxQ2hDLFlBQWdDLEdBQW9CLEVBQ3BCLEtBQW1CLEVBQ25CLFlBQXlCLEVBQ3pCLFFBQWtCO1FBSGxCLFFBQUcsR0FBSCxHQUFHLENBQWlCO1FBQ3BCLFVBQUssR0FBTCxLQUFLLENBQWM7UUFDbkIsaUJBQVksR0FBWixZQUFZLENBQWE7UUFDekIsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQXRDbEQsbUNBQW1DO1FBQzNCLGNBQVMsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO1FBQ2pDLGFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUM7SUFxQ2pFLENBQUM7SUFsQkQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsS0FBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3RDLENBQUM7SUFFRCx3QkFBd0I7SUFDeEIsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMs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QUFDLEVBQ3BFLEdBQUcsQ0FBQyxDQUFDLFFBQWdCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFDbEQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUNuQixDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7O3lHQXpGbUIsWUFBWSw2RUF1Q2MsV0FBVyxhQUNmLFFBQVE7NkZBeEM5QixZQUFZOzJGQUFaLFlBQVk7a0JBRGpDLFNBQVM7bUhBd0NzQyxXQUFXLFlBQ2YsUUFBUSwwQkFwQ3hDLFFBQVE7c0JBQWpCLE1BQU07O0FBdUdUOztHQUVHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxTQUFpQixFQUFFLFdBQW1CLEVBQUUsWUFBb0I7SUFDdEYsTUFBTSxjQUFjLEdBQUcsU0FBUyxHQUFHLFdBQVcsQ0FBQztJQUMvQyxNQUFNLFNBQVMsR0FBRyxjQUFjLEdBQUcsU0FBUyxDQUFDO0lBQzdDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQzdDLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsc0JBQXNCLENBQUMsY0FBc0IsRUFBRSxTQUFpQixFQUFFLFFBQWdCO0lBQ3pGLE9BQU8sY0FBYyxHQUFHLFFBQVEsR0FBRyxTQUFTLENBQUM7QUFDL0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE91dHB1dCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBvZiwgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIG1lcmdlTWFwLCBwbHVjaywgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGVuYWJsZVNlbGVjdGlvbiwgcHJldmVudFNlbGVjdGlvbiwgc3RvcFByb3BhZ2F0aW9uIH0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgVHJhY2tBZGFwdGVyIH0gZnJvbSAnLi4vdHJhY2svdHJhY2snO1xyXG5pbXBvcnQgeyBOZ1Njcm9sbGJhckJhc2UgfSBmcm9tICcuLi8uLi9uZy1zY3JvbGxiYXItYmFzZSc7XHJcblxyXG4vLyBAZHluYW1pY1xyXG5ARGlyZWN0aXZlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRodW1iQWRhcHRlciB7XHJcblxyXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIGRyYWdnaW5nIHN0YXRlXHJcbiAgcHJpdmF0ZSBfZHJhZ2dpbmcgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xyXG4gIEBPdXRwdXQoKSBkcmFnZ2luZyA9IHRoaXMuX2RyYWdnaW5nLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XHJcblxyXG4gIC8vIFJldHVybnMgZWl0aGVyICdwYWdlWCcgb3IgJ3BhZ2VZJyBhY2NvcmRpbmcgdG8gc2Nyb2xsYmFyIGF4aXNcclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHBhZ2VQcm9wZXJ0eSgpOiBzdHJpbmc7XHJcblxyXG4gIC8vIFJldHVybnMgZWl0aGVyICdjbGllbnRIZWlnaHQnIG9yICdjbGllbnRXaWR0aCcgYWNjb3JkaW5nIHRvIHNjcm9sbGJhciBheGlzXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCBjbGllbnRQcm9wZXJ0eSgpOiBzdHJpbmc7XHJcblxyXG4gIGFic3RyYWN0IGdldCBkcmFnU3RhcnRPZmZzZXQoKTogbnVtYmVyO1xyXG5cclxuICAvLyBSZXR1cm5zIHRodW1iIHNpemUsIGNsaWVudEhlaWdodCBvciBjbGllbnRXaWR0aFxyXG4gIGFic3RyYWN0IGdldCBzaXplKCk6IG51bWJlcjtcclxuXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCB2aWV3cG9ydFNjcm9sbFNpemUoKTogbnVtYmVyO1xyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHZpZXdwb3J0U2Nyb2xsT2Zmc2V0KCk6IG51bWJlcjtcclxuXHJcbiAgYWJzdHJhY3QgZ2V0IHZpZXdwb3J0U2Nyb2xsTWF4KCk6IG51bWJlcjtcclxuXHJcbiAgZ2V0IHRyYWNrTWF4KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFjayEuc2l6ZSAtIHRoaXMuc2l6ZTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aHVtYiBjbGllbnQgcmVjdFxyXG4gIGdldCBjbGllbnRSZWN0KCk6IERPTVJlY3Qge1xyXG4gICAgcmV0dXJuIHRoaXMudGh1bWJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGxiYXIgdGh1bWIgaXMgY2xpY2tlZFxyXG4gIGdldCBjbGlja2VkKCk6IE9ic2VydmFibGU8TW91c2VFdmVudD4ge1xyXG4gICAgcmV0dXJuIGZyb21FdmVudDxNb3VzZUV2ZW50Pih0aGlzLnRodW1iRWxlbWVudCwgJ21vdXNlZG93bicsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKHN0b3BQcm9wYWdhdGlvbigpKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY21wOiBOZ1Njcm9sbGJhckJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RlY3RlZCB0cmFjazogVHJhY2tBZGFwdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgdGh1bWJFbGVtZW50OiBIVE1MRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIGRvY3VtZW50OiBEb2N1bWVudCkge1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGFuZCB1cGRhdGUgdGh1bWIgcG9zaXRpb24gYW5kIHNpemVcclxuICB1cGRhdGUoKSB7XHJcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlVGh1bWJTaXplKHRoaXMudHJhY2shLnNpemUsIHRoaXMudmlld3BvcnRTY3JvbGxTaXplLCB0aGlzLmNtcC5taW5UaHVtYlNpemUhKTtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gY2FsY3VsYXRlVGh1bWJQb3NpdGlvbih0aGlzLnZpZXdwb3J0U2Nyb2xsT2Zmc2V0LCB0aGlzLnZpZXdwb3J0U2Nyb2xsTWF4LCB0aGlzLnRyYWNrTWF4KTtcclxuICAgIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLnNjaGVkdWxlKCgpID0+IHRoaXMudXBkYXRlU3R5bGVzKHRoaXMuaGFuZGxlRGlyZWN0aW9uKHBvc2l0aW9uLCB0aGlzLnRyYWNrTWF4KSwgc2l6ZSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RyZWFtIHRoYXQgZW1pdHMgdGhlICdzY3JvbGxUbycgcG9zaXRpb24gd2hlbiBhIHNjcm9sbGJhciB0aHVtYiBlbGVtZW50IGlzIGRyYWdnZWRcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aHVtYiBkcmFnIGV2ZW50IHVzaW5nIHZpZXdwb3J0IG9yIHNjcm9sbGJhciBwb2ludGVyIGV2ZW50c1xyXG4gICAqL1xyXG4gIGRyYWdnZWQoZXZlbnQ6IE1vdXNlRXZlbnQpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gICAgbGV0IHRyYWNrTWF4U3RhcnQ6IG51bWJlcjtcclxuICAgIGxldCBzY3JvbGxNYXhTdGFydDogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydCA9IG9mPE1vdXNlRXZlbnQ+KGV2ZW50KS5waXBlKFxyXG4gICAgICBwcmV2ZW50U2VsZWN0aW9uKHRoaXMuZG9jdW1lbnQpLFxyXG4gICAgICB0YXAoKCkgPT4ge1xyXG4gICAgICAgIC8vIENhcHR1cmUgc2Nyb2xsTWF4IGFuZCB0cmFja01heCBvbmNlXHJcbiAgICAgICAgdHJhY2tNYXhTdGFydCA9IHRoaXMudHJhY2tNYXg7XHJcbiAgICAgICAgc2Nyb2xsTWF4U3RhcnQgPSB0aGlzLnZpZXdwb3J0U2Nyb2xsTWF4O1xyXG4gICAgICAgIHRoaXMuc2V0RHJhZ2dpbmcodHJ1ZSk7XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBkcmFnZ2luZyA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pih0aGlzLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoc3RvcFByb3BhZ2F0aW9uKCkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdFbmQgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5kb2N1bWVudCwgJ21vdXNldXAnLCB7IGNhcHR1cmU6IHRydWUgfSkucGlwZShcclxuICAgICAgc3RvcFByb3BhZ2F0aW9uKCksXHJcbiAgICAgIGVuYWJsZVNlbGVjdGlvbih0aGlzLmRvY3VtZW50KSxcclxuICAgICAgdGFwKCgpID0+IHRoaXMuc2V0RHJhZ2dpbmcoZmFsc2UpKVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gZHJhZ1N0YXJ0LnBpcGUoXHJcbiAgICAgIHBsdWNrPGFueSwgc3RyaW5nPih0aGlzLnBhZ2VQcm9wZXJ0eSksXHJcbiAgICAgIG1hcCgocGFnZU9mZnNldDogbnVtYmVyKSA9PiBwYWdlT2Zmc2V0IC0gdGhpcy5kcmFnU3RhcnRPZmZzZXQpLFxyXG4gICAgICBtZXJnZU1hcCgobW91c2VEb3duT2Zmc2V0OiBudW1iZXIpID0+IGRyYWdnaW5nLnBpcGUoXHJcbiAgICAgICAgcGx1Y2sodGhpcy5jbGllbnRQcm9wZXJ0eSksXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgdGhlIHBvaW50ZXIgaXMgZnJvbSB0aGUgdG9wL2xlZnQgb2YgdGhlIHNjcm9sbGJhciAobWludXMgdGhlIGRyYWdPZmZzZXQpLlxyXG4gICAgICAgIG1hcCgobW91c2VPZmZzZXQ6IG51bWJlcikgPT4gbW91c2VPZmZzZXQgLSB0aGlzLnRyYWNrIS5vZmZzZXQpLFxyXG4gICAgICAgIG1hcCgob2Zmc2V0OiBudW1iZXIpID0+IHNjcm9sbE1heFN0YXJ0ICogKG9mZnNldCAtIG1vdXNlRG93bk9mZnNldCkgLyB0cmFja01heFN0YXJ0KSxcclxuICAgICAgICBtYXAoKHBvc2l0aW9uOiBudW1iZXIpID0+IHRoaXMuaGFuZGxlRHJhZyhwb3NpdGlvbiwgc2Nyb2xsTWF4U3RhcnQpKSxcclxuICAgICAgICB0YXAoKHBvc2l0aW9uOiBudW1iZXIpID0+IHRoaXMuc2Nyb2xsVG8ocG9zaXRpb24pKSxcclxuICAgICAgICB0YWtlVW50aWwoZHJhZ0VuZClcclxuICAgICAgKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBTZXQgZHJhZ2dpbmcgc3RhdGVcclxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2V0RHJhZ2dpbmcodmFsdWU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAvLyBTY3JvbGwgdmlld3BvcnQgaW5zdGFudGx5XHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNjcm9sbFRvKHBvc2l0aW9uOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAvLyBVcGRhdGUgdGh1bWIgZWxlbWVudCBzaXplIGFuZCBwb3NpdGlvblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCB1cGRhdGVTdHlsZXMocG9zaXRpb246IG51bWJlciwgc2l6ZTogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgLy8gSGFuZGxlIGRyYWdnaW5nIHBvc2l0aW9uIChTdXBwb3J0IExUUiBhbmQgUlRMIGRpcmVjdGlvbnMgZm9yIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhcilcclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgaGFuZGxlRHJhZyhwb3NpdGlvbjogbnVtYmVyLCBzY3JvbGxNYXg/OiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gIC8vIEhhbmRsZSBzY3JvbGxpbmcgcG9zaXRpb24gKFN1cHBvcnQgTFRSIGFuZCBSVEwgZGlyZWN0aW9ucyBmb3IgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyKVxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBoYW5kbGVEaXJlY3Rpb24ocG9zaXRpb246IG51bWJlciwgc2Nyb2xsTWF4PzogbnVtYmVyKTogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHNjcm9sbGJhciB0aHVtYiBzaXplXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVUaHVtYlNpemUodHJhY2tTaXplOiBudW1iZXIsIGNvbnRlbnRTaXplOiBudW1iZXIsIG1pblRodW1iU2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICBjb25zdCBzY3JvbGxiYXJSYXRpbyA9IHRyYWNrU2l6ZSAvIGNvbnRlbnRTaXplO1xyXG4gIGNvbnN0IHRodW1iU2l6ZSA9IHNjcm9sbGJhclJhdGlvICogdHJhY2tTaXplO1xyXG4gIHJldHVybiBNYXRoLm1heCh+fnRodW1iU2l6ZSwgbWluVGh1bWJTaXplKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBzY3JvbGxiYXIgdGh1bWIgcG9zaXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRodW1iUG9zaXRpb24oc2Nyb2xsUG9zaXRpb246IG51bWJlciwgc2Nyb2xsTWF4OiBudW1iZXIsIHRyYWNrTWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gIHJldHVybiBzY3JvbGxQb3NpdGlvbiAqIHRyYWNrTWF4IC8gc2Nyb2xsTWF4O1xyXG59XHJcbiJdfQ==